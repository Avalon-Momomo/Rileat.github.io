<script>
  /* ================== 动态天气背景（画布） ================== */
  const canvas = document.getElementById("weather-bg");
  const ctx = canvas.getContext("2d");

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  // 粒子容器
  let rainDrops = [];
  let snowFlakes = [];
  let stars = [];
  let foregroundClouds = [];
  let backgroundClouds = [];

  let weatherMode = "sun";         // sun / cloud / rain / storm / snow / night
  let timeOfDay = "day";           // day / evening / night / dawn
  let windX = 0;

  let targetSky = { top: "#57A8FF", bottom: "#CBE7FF" };
  let currentSky = { top: "#57A8FF", bottom: "#CBE7FF" };

  const skyPresets = {
    sun_day:   { top: "#57A8FF", bottom: "#CBE7FF" },
    sun_even:  { top: "#FF9A62", bottom: "#FFCF96" },
    sun_dawn:  { top: "#FF8BA7", bottom: "#FCD5CE" },
    cloud:     { top: "#7D8FA3", bottom: "#C6D0DD" },
    rain:      { top: "#4B5666", bottom: "#767F8A" },
    storm:     { top: "#3B404C", bottom: "#5A6470" },
    snow:      { top: "#90C2FF", bottom: "#E1F0FF" },
    night:     { top: "#050816", bottom: "#090F2A" }
  };

  function createRain(intensity = 1) {
    rainDrops = [];
    const base = 400 * (window.innerWidth / 800);
    const count = Math.floor(base * intensity);
    for (let i=0;i<count;i++) {
      rainDrops.push({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height,
        len: 8 + Math.random()*10,
        speedY: 8 + Math.random()*7,
        speedX: windX + (Math.random()-0.5)*0.8
      });
    }
  }

  function createSnow(intensity = 1) {
    snowFlakes = [];
    const base = 160 * (window.innerWidth / 800);
    const count = Math.floor(base * intensity);
    for (let i=0;i<count;i++) {
      snowFlakes.push({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height,
        r: 1.5 + Math.random()*2.5,
        speedY: 1 + Math.random()*1.5,
        offset: Math.random()*Math.PI*2
      });
    }
  }

  function createStars() {
    stars = [];
    const count = 140;
    for (let i=0;i<count;i++) {
      stars.push({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height*0.6,
        r: Math.random()*1.2 + 0.4,
        alpha: Math.random(),
        speed: Math.random()*0.015 + 0.005
      });
    }
  }

  function createCloudLayer() {
    foregroundClouds = [];
    backgroundClouds = [];
    const fgCount = 6;
    const bgCount = 5;

    for (let i=0;i<fgCount;i++) {
      foregroundClouds.push({
        x: Math.random()*canvas.width,
        y: canvas.height*0.25 + Math.random()*canvas.height*0.25,
        w: 220 + Math.random()*160,
        h: 60 + Math.random()*30,
        speed: 0.22 + Math.random()*0.15
      });
    }

    for (let i=0;i<bgCount;i++) {
      backgroundClouds.push({
        x: Math.random()*canvas.width,
        y: canvas.height*0.12 + Math.random()*canvas.height*0.18,
        w: 260 + Math.random()*200,
        h: 70 + Math.random()*30,
        speed: 0.08 + Math.random()*0.10
      });
    }
  }

  function drawCloud(x,y,w,h,alpha) {
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,"+alpha+")";
    ctx.beginPath();
    ctx.ellipse(x, y, w*0.45, h*0.5, 0, 0, Math.PI*2);
    ctx.ellipse(x-w*0.25, y+5, w*0.3, h*0.4, 0, 0, Math.PI*2);
    ctx.ellipse(x+w*0.25, y+8, w*0.3, h*0.4, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawSunOrMoon(type) {
    const cx = canvas.width * 0.18;
    const cy = canvas.height * 0.22;

    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 100);
    if (type === "sun") {
      gradient.addColorStop(0, "rgba(255,255,255,0.95)");
      gradient.addColorStop(0.4, "rgba(255,255,200,0.85)");
      gradient.addColorStop(1, "rgba(255,255,200,0)");
    } else {
      gradient.addColorStop(0, "rgba(255,255,255,0.95)");
      gradient.addColorStop(0.4, "rgba(200,220,255,0.8)");
      gradient.addColorStop(1, "rgba(200,220,255,0)");
    }

    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(cx, cy, 100, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = type === "sun"
      ? "rgba(255,255,255,0.96)"
      : "rgba(230,240,255,0.96)";
    ctx.beginPath();
    ctx.arc(cx, cy, 28, 0, Math.PI*2);
    ctx.fill();
  }

  function lerpColor(c1, c2, t) {
    const a = hexToRgb(c1), b = hexToRgb(c2);
    const r = Math.round(a.r + (b.r-a.r)*t);
    const g = Math.round(a.g + (b.g-a.g)*t);
    const b2 = Math.round(a.b + (b.b-a.b)*t);
    return `rgb(${r},${g},${b2})`;
  }

  function hexToRgb(c) {
    if (c.startsWith("rgb")) {
      const m = c.match(/\d+/g);
      return { r:+m[0], g:+m[1], b:+m[2] };
    }
    let hex = c.replace("#","");
    if (hex.length===3) hex = hex.split("").map(x=>x+x).join("");
    const num = parseInt(hex,16);
    return { r:(num>>16)&255, g:(num>>8)&255, b:num&255 };
  }

  let lastTime = 0;
  function animate(t) {
    requestAnimationFrame(animate);
    const dt = (t - lastTime)/16.67 || 1;
    lastTime = t;

    // 天空颜色缓动
    const lerp = 0.03;
    currentSky.top = lerpColor(currentSky.top, targetSky.top, lerp);
    currentSky.bottom = lerpColor(currentSky.bottom, targetSky.bottom, lerp);

    // 渐变背景
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0, currentSky.top);
    g.addColorStop(1, currentSky.bottom);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // 星星（夜晚）
    if (weatherMode === "night") {
      stars.forEach(s => {
        s.alpha += s.speed * (Math.random()<0.5?-1:1);
        if (s.alpha < 0.2) s.alpha = 0.2;
        if (s.alpha > 1) s.alpha = 1;
        ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
        ctx.fill();
      });
    }

    // 太阳 / 月亮
    if (weatherMode !== "night") {
      drawSunOrMoon("sun");
    } else {
      drawSunOrMoon("moon");
    }

    // 云层
    if (["sun","cloud","rain","storm","snow"].includes(weatherMode)) {
      backgroundClouds.forEach(c => {
        c.x += c.speed * dt;
        if (c.x - c.w > canvas.width) c.x = -c.w;
        drawCloud(c.x, c.y, c.w, c.h, 0.18);
      });

      foregroundClouds.forEach(c => {
        c.x += c.speed * dt;
        if (c.x - c.w > canvas.width) c.x = -c.w;
        drawCloud(c.x, c.y, c.w, c.h, 0.26);
      });
    }

    // 雨
    if (weatherMode === "rain" || weatherMode === "storm") {
      ctx.strokeStyle = "rgba(255,255,255,0.45)";
      ctx.lineWidth = 1.2;
      rainDrops.forEach(d => {
        ctx.beginPath();
        ctx.moveTo(d.x, d.y);
        ctx.lineTo(d.x + d.speedX*1.2, d.y + d.len);
        ctx.stroke();

        d.x += d.speedX * dt;
        d.y += d.speedY * dt;

        if (d.y > canvas.height + 20) {
          d.y = -20;
          d.x = Math.random()*canvas.width;
        }
      });

      // 闪电效果（偶尔闪一下）
      if (weatherMode === "storm" && Math.random() < 0.004) {
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
      }
    }

    // 雪
    if (weatherMode === "snow") {
      ctx.fillStyle = "rgba(255,255,255,0.96)";
      snowFlakes.forEach(f => {
        f.y += f.speedY * dt;
        f.x += Math.sin(f.offset + t*0.0015) * 0.5 * dt;
        if (f.y > canvas.height+10) {
          f.y = -10;
          f.x = Math.random()*canvas.width;
        }
        ctx.beginPath();
        ctx.arc(f.x, f.y, f.r, 0, Math.PI*2);
        ctx.fill();
      });
    }
  }
  requestAnimationFrame(animate);

  function setWeatherVisual(conditionText, localtimeStr, isDayFlag) {
    const text = (conditionText || "").toLowerCase();

    let hour = null;
    if (localtimeStr) {
      const m = localtimeStr.match(/\d{4}-\d{2}-\d{2} (\d{2})/);
      if (m) hour = parseInt(m[1],10);
    }
    if (hour !== null) {
      if (hour >= 20 || hour < 5) timeOfDay = "night";
      else if (hour >= 17) timeOfDay = "evening";
      else if (hour < 8)  timeOfDay = "dawn";
      else               timeOfDay = "day";
    } else {
      timeOfDay = isDayFlag ? "day" : "night";
    }

    if (/thunder|storm|雷/.test(text)) {
      weatherMode = "storm";
      targetSky = skyPresets.storm;
      windX = 2.5;
      createRain(1.3);
      createCloudLayer();
    } else if (/rain|drizzle|阵雨|雨/.test(text)) {
      weatherMode = "rain";
      targetSky = skyPresets.rain;
      windX = 1.5;
      createRain(1.0);
      createCloudLayer();
    } else if (/snow|sleet|雪/.test(text)) {
      weatherMode = "snow";
      targetSky = skyPresets.snow;
      windX = 0.3;
      createSnow(1.0);
      createCloudLayer();
    } else if (/cloud|overcast|多云|阴/.test(text)) {
      weatherMode = "cloud";
      targetSky = skyPresets.cloud;
      windX = 0.6;
      createCloudLayer();
      rainDrops = [];
      snowFlakes = [];
    } else if (timeOfDay === "night") {
      weatherMode = "night";
      targetSky = skyPresets.night;
      windX = 0.1;
      createStars();
      createCloudLayer();
      rainDrops = [];
      snowFlakes = [];
    } else {
      weatherMode = "sun";
      if (timeOfDay === "evening")      targetSky = skyPresets.sun_even;
      else if (timeOfDay === "dawn")    targetSky = skyPresets.sun_dawn;
      else                              targetSky = skyPresets.sun_day;
      windX = 0.4;
      rainDrops = [];
      snowFlakes = [];
      createCloudLayer();
      stars = [];
    }
  }

  /* ================== WeatherAPI + 苹果 UI ================== */

  const API_KEY = "0871934c91a1479984b40316250912";

  const cityEl       = document.getElementById("city");
  const timeEl       = document.getElementById("localtime");
  const tempEl       = document.getElementById("temp");
  const condEl       = document.getElementById("condition");
  const hiLoEl       = document.getElementById("hiLo");
  const iconEl       = document.getElementById("icon");
  const feelsEl      = document.getElementById("feelsLike");
  const windEl       = document.getElementById("wind");
  const humidityEl   = document.getElementById("humidity");
  const uvEl         = document.getElementById("uv");
  const pressureEl   = document.getElementById("pressure");
  const visEl        = document.getElementById("visibility");
  const cloudEl      = document.getElementById("cloud");
  const updatedEl    = document.getElementById("updated");

  const searchInput  = document.getElementById("search");
  const searchBtn    = document.getElementById("searchBtn");
  const locBtn       = document.getElementById("locBtn");

  // ⭐ 对用户输入做智能预处理
  function normalizeLocationInput(raw) {
    let q = (raw || "").trim();
    if (!q) return "";

    // 去掉前缀“中国”“中华人民共和国”
    q = q.replace(/中国|中华人民共和国/gi, "");

    // 去掉“区号”字样
    q = q.replace(/区号/gi, "");

    // 去掉结尾的 省/市/区/县（例如 “上海市” -> “上海”）
    q = q.replace(/[省市区县]\s*$/gi, "");

    // 中文逗号换成空格
    q = q.replace(/[，,]+/g, " ");

    // 多空格压缩
    q = q.replace(/\s+/g, " ").trim();

    // 如果只输入 4 位数字，当成澳洲邮编（2138 -> "2138 Australia"）
    if (/^\d{4}$/.test(q)) {
      q = q + " Australia";
    }

    return q;
  }

  searchBtn.addEventListener("click", () => {
    const val = normalizeLocationInput(searchInput.value);
    if (!val) return;
    fetchWeatherByQuery(val);
  });

  searchInput.addEventListener("keydown", e => {
    if (e.key === "Enter") searchBtn.click();
  });

  locBtn.addEventListener("click", autoLocate);

  async function fetchWeatherByQuery(q) {
    const norm = normalizeLocationInput(q);
    if (!norm) return;

    try {
      const url = `https://api.weatherapi.com/v1/current.json?key=${API_KEY}&q=${encodeURIComponent(norm)}&aqi=no`;
      const res = await fetch(url);
      const data = await res.json();
      if (data.error) throw new Error(data.error.message);
      updateUI(data);
    } catch (e) {
      alert("获取天气失败，请检查城市或邮编后重试");
      console.error(e);
    }
  }

  function updateUI(data) {
    const loc = data.location;
    const c   = data.current;

    cityEl.textContent = `${loc.name}, ${loc.region || loc.country}`;
    timeEl.textContent = `当地时间：${loc.localtime}`;
    tempEl.textContent = `${Math.round(c.temp_c)}°`;
    condEl.textContent = c.condition.text;
    iconEl.src = "https:" + c.condition.icon;
    iconEl.alt = c.condition.text;

    const hi = Math.round(c.temp_c + 2);
    const lo = Math.round(c.temp_c - 2);
    hiLoEl.textContent = `最高 ${hi}° · 最低 ${lo}°`;

    feelsEl.textContent    = `体感：${Math.round(c.feelslike_c)}°`;
    windEl.textContent     = `${c.wind_kph} km/h`;
    humidityEl.textContent = `${c.humidity}%`;
    uvEl.textContent       = `${c.uv}`;
    pressureEl.textContent = c.pressure_mb ? `${c.pressure_mb} hPa` : "—";
    visEl.textContent      = c.vis_km !== undefined ? `${c.vis_km} km` : "—";
    cloudEl.textContent    = c.cloud !== undefined ? `${c.cloud}%` : "—";

    const now = new Date();
    updatedEl.textContent = `上次更新：${now.toLocaleTimeString()}`;

    // 动态背景效果
    setWeatherVisual(c.condition.text, loc.localtime, c.is_day === 1);
  }

  function autoLocate() {
    if (!navigator.geolocation) {
      fetchWeatherByQuery("Sydney");
      return;
    }
    navigator.geolocation.getCurrentPosition(
      pos => {
        const q = `${pos.coords.latitude},${pos.coords.longitude}`;
        fetchWeatherByQuery(q); // 这里不用规范化，直接坐标
      },
      err => {
        console.warn("定位失败，使用默认城市", err);
        fetchWeatherByQuery("Sydney");
      }
    );
  }

  // 初始加载
  autoLocate();
</script>
